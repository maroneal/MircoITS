/**
* This program draws the course of the robot on the circuit (square of 2m width). It needs one file called "log_format_camera_mm.csv" and can be generated from the Java program called "Parse_file" which parses a file generated by the main program "MicroITS" on the robot.
*/

final int SQUARE_WIDTH = 1;
final int LINE_WIDTH = 500;
final int WIDTH_WINDOW = 1024;
final int HEIGHT_WINDOW = 768;

int lastX, lastY;
int varX, varY;
int count;

void setup()
{
  size(1024, 768);
  background(255);
  
  /****** Initialization variable ******/
  int xOriginDrawing = WIDTH_WINDOW/2 - LINE_WIDTH/2;
  int yOriginDrawing = HEIGHT_WINDOW/2 - LINE_WIDTH/2;
  //PImage realCircuit;  // Image of the circuit for the background
  Table positions;  // Table of the positions
  
  /****** Loading table of positions ******/
  positions = loadTable("log_format_camera_mm.csv", "header");
  
  /****** Loading image of the circuit for the background ******/
  //realCircuit = loadImage("./circuit.png");
  //image(realCircuit, 0, 0);
  
  /****** Draw the circuit if no pictures of the circuit ******/
  drawCircuit();
  
  /****** Draw the positions ******/
  drawTrajectory(positions, xOriginDrawing, yOriginDrawing); 
  
  /****** Draw the caption ******/
  //showCaption();
}

void drawSquare(int x, int y)
{
  fill(255, 0, 0);
  stroke(255, 0, 0);
  strokeWeight(8);
  //rect(x, y, SQUARE_WIDTH, SQUARE_WIDTH);
  ellipse(x, y, SQUARE_WIDTH, SQUARE_WIDTH);
}

void drawCircuit()
{
  strokeWeight(2);
  rect(WIDTH_WINDOW/2 - LINE_WIDTH/2, HEIGHT_WINDOW/2 - LINE_WIDTH/2, LINE_WIDTH, LINE_WIDTH);
}

void showCaption()
{
  stroke(0);
  strokeWeight(2);
  fill(0);
  
  /*text("Measured axis", 10, 10);
  arrowLine(50, 30, 100, 30, 0, 1, true);
  arrowLine(50, 30, 50, 80, 0, 1, true);
  text("X", 40, 55);
  text("Y", 75, 25);
  
  text("Drawing axis", 150, 10);
  arrowLine(190, 30, 240, 30, 0, 1, true);
  arrowLine(190, 30, 190, 80, 0, 1, true);
  text("Y", 180, 55);
  text("X", 215, 25);*/
  
    /****** Scale ******/
  /*text("Scale : ", 10, 350);
  line(10, 360, 10 + LINE_WIDTH/10, 360);
  text("20 centimeters", 10 + LINE_WIDTH/10 + 10, 360);*/
  
  /****** Start & end ******/
  /*text("Start & End", WIDTH_WINDOW/2 - LINE_WIDTH/2 - 30, HEIGHT_WINDOW/2 - LINE_WIDTH/2 - 30);
  arrowLine(WIDTH_WINDOW/2 - LINE_WIDTH/2 - 20, HEIGHT_WINDOW/2 - LINE_WIDTH/2 + 20, WIDTH_WINDOW/2 - LINE_WIDTH/2 - 20, HEIGHT_WINDOW/2 - LINE_WIDTH/2 + 20 + 50, 0, 1, true);
  text("Direction of the robot", WIDTH_WINDOW/2 - LINE_WIDTH/2 - 150, HEIGHT_WINDOW/2 - LINE_WIDTH/2 + 45);*/
  
  textSize(27);
  text("Scale : ", 10, 350);
  line(10, 400, 10 + LINE_WIDTH/10, 400);
  line(10, 390, 10, 410);
  line(10 + LINE_WIDTH/10, 390, 10 + LINE_WIDTH/10, 410);
  text("20 centimeters", 10, 450);
  
  /****** Start & end ******/
  text("Start & End", WIDTH_WINDOW/2 - LINE_WIDTH/2 - 60, HEIGHT_WINDOW/2 - LINE_WIDTH/2 - 30);
  arrowLine(WIDTH_WINDOW/2 - LINE_WIDTH/2 - 20, HEIGHT_WINDOW/2 - LINE_WIDTH/2 + 20, WIDTH_WINDOW/2 - LINE_WIDTH/2 - 20, HEIGHT_WINDOW/2 - LINE_WIDTH/2 + 20 + 50, 0, 1, true);
  text("Direction of\nthe robot", WIDTH_WINDOW/2 - LINE_WIDTH/2 - 200, HEIGHT_WINDOW/2 - LINE_WIDTH/2 + 45);
}

void drawTrajectory(Table table, int x0, int y0)
{
  // Declaration of the variables used for the position
  final int NB_POSITIONS = table.getRowCount();
  float[] x = new float[NB_POSITIONS];
  float[] y = new float[NB_POSITIONS];
  int index = 0;
  int x0Measure = 0, y0Measure = 0;
  
  println("Number of rows : " + table.getRowCount());
  println("Number of columns : " + table.getColumnCount());
  x0Measure = reScale((int)table.getFloat(0, "Y Position"));
  y0Measure = reScale((int)table.getFloat(0, "X Position"));
  
  lastX = x0Measure;
  lastY = y0Measure;
  
  for (TableRow row : table.rows()) 
  {  
    x[index] = reScale((int)row.getFloat("Y Position")) - x0Measure;
    y[index] = reScale((int)row.getFloat("X Position")) - y0Measure;
    
    println("X : "  + x[index] + "; Y : " + y[index]);
    
    drawSquare((int)x[index] + x0, (int)y[index] + y0);
    drawLine(lastX, lastY, (int)x[index] + x0, (int)y[index] + y0);
    
    lastX = (int)x[index] + x0;
    lastY = (int)y[index] + y0;
    
    index++;
  }
}

//void drawTrajectory(Table table, int x0, int y0)
//{
//  // Declaration of the variables used for the position
//  final int NB_POSITIONS = table.getRowCount();
//  final int NB_COUNT = 10;
//  float[] x = new float[NB_POSITIONS];
//  float[] y = new float[NB_POSITIONS];
//  int index = 0;
//  int x0Measure = 0, y0Measure = 0;
  
//  strokeWeight(5);
  
//  println("Number of rows : " + table.getRowCount());
//  println("Number of columns : " + table.getColumnCount());
//  x0Measure = reScale((int)table.getFloat(0, "Y Position"));
//  y0Measure = reScale((int)table.getFloat(0, "X Position"));
  
//  lastX = x0Measure;
//  lastY = y0Measure;
//  varX = 0;
//  varY = 0;
//  count = 0;
  
//  for (TableRow row : table.rows()) 
//  { 
//    if(count >= NB_COUNT)
//    { 
//      x[index] = varX / NB_COUNT;
//      y[index] = varY / NB_COUNT;
    
//      println("X : "  + x[index] + "; Y : " + y[index]);
      
//      drawSquare((int)x[index] + x0, (int)y[index] + y0);
//      drawLine(lastX, lastY, (int)x[index] + x0, (int)y[index] + y0);
      
//      lastX = (int)x[index] + x0;
//      lastY = (int)y[index] + y0;
//      index++;
      
//      count = 0;
//      varX = 0;
//      varY = 0;
//    }
//    else
//    {
//      varX += reScale((int)row.getFloat("Y Position")) - x0Measure;
//      varY += reScale((int)row.getFloat("X Position")) - y0Measure;
//      count++;
//    }
//  }
//}

void drawLine(int x1, int y1, int x2, int y2)
{
  strokeWeight(1);
  stroke(255, 0, 0);
  line(x1, y1, x2, y2);
} //<>//

int reScale(int var)
{
  return var * LINE_WIDTH / 200;
}

/*
 * Draws a lines with arrows of the given angles at the ends.
 * x0 - starting x-coordinate of line
 * y0 - starting y-coordinate of line
 * x1 - ending x-coordinate of line
 * y1 - ending y-coordinate of line
 * startAngle - angle of arrow at start of line (in radians)
 * endAngle - angle of arrow at end of line (in radians)
 * solid - true for a solid arrow; false for an "open" arrow
 */
void arrowLine(float x0, float y0, float x1, float y1,
  float startAngle, float endAngle, boolean solid)
{
  line(x0, y0, x1, y1);
  if (startAngle != 0)
  {
    arrowhead(x0, y0, atan2(y1 - y0, x1 - x0), startAngle, solid);
  }
  if (endAngle != 0)
  {
    arrowhead(x1, y1, atan2(y0 - y1, x0 - x1), endAngle, solid);
  }
}

/*
 * Draws an arrow head at given location
 * x0 - arrow vertex x-coordinate
 * y0 - arrow vertex y-coordinate
 * lineAngle - angle of line leading to vertex (radians)
 * arrowAngle - angle between arrow and line (radians)
 * solid - true for a solid arrow, false for an "open" arrow
 */
void arrowhead(float x0, float y0, float lineAngle,
  float arrowAngle, boolean solid)
{
  float phi;
  float x2;
  float y2;
  float x3;
  float y3;
  final float SIZE = 8;
  
  x2 = x0 + SIZE * cos(lineAngle + arrowAngle);
  y2 = y0 + SIZE * sin(lineAngle + arrowAngle);
  x3 = x0 + SIZE * cos(lineAngle - arrowAngle);
  y3 = y0 + SIZE * sin(lineAngle - arrowAngle);
  if (solid)
  {
    triangle(x0, y0, x2, y2, x3, y3);
  }
  else
  {
    line(x0, y0, x2, y2);
    line(x0, y0, x3, y3);
  }  
}
